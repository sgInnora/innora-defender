#!/usr/bin/env python3
"""
YARA Rule Generator
Creates YARA rules from ransomware analysis data and threat intelligence.
"""

import os
import re
import json
import uuid
import logging
import datetime
from typing import Dict, List, Any, Optional, Set, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('yara_generator')

class YaraRuleGenerator:
    """Generates YARA rules from threat intelligence and analysis data"""
    
    def __init__(self, rules_dir=None):
        """
        Initialize the YARA rule generator
        
        Args:
            rules_dir: Directory to store generated rules
        """
        self.rules_dir = rules_dir or os.path.join(
            os.path.dirname(os.path.dirname(__file__)), 'rules', 'generated'
        )
        os.makedirs(self.rules_dir, exist_ok=True)
        
        # Initialize templates directory
        self.templates_dir = os.path.join(os.path.dirname(__file__), 'templates')
        os.makedirs(self.templates_dir, exist_ok=True)
        self._create_default_templates()
    
    def _create_default_templates(self):
        """Create default YARA rule templates"""
        template_file = os.path.join(self.templates_dir, 'ransomware_template.yara')
        if not os.path.exists(template_file):
            with open(template_file, 'w') as f:
                f.write("""rule {rule_name}
{
    meta:
        description = "{description}"
        author = "Auto-generated by Threat Intel Analyzer"
        date = "{date}"
        hash = "{hash}"
        family = "{family}"
        confidence = "{confidence}"
        threat_level = "{threat_level}"
        reference = "{reference}"
        tags = "{tags}"
        
    strings:
{string_definitions}
        
    condition:
        {condition}
}
""")
    
    def _extract_yara_strings(self, sample_data: Dict) -> List[Dict]:
        """
        Extract strings suitable for YARA rules from sample data
        
        Args:
            sample_data: Sample analysis data
            
        Returns:
            List of extracted strings with metadata
        """
        yara_strings = []
        
        # Check if we have strings to work with
        strings = sample_data.get('analysis', {}).get('strings', [])
        if not strings:
            return yara_strings
        
        # Process strings for YARA compatibility
        interesting_patterns = [
            # File extensions
            r'\.(\w+)$',
            # URLs and domains
            r'https?://[^\s/$.?#].[^\s]*',
            r'(?:www\.)?(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}',
            # Ransomware related
            r'ransom', r'crypt', r'decrypt', r'bitcoin', r'payment', r'wallet', r'btc',
            r'unlock', r'key', r'victim', r'\$[0-9]+', r'[0-9]+ (usd|dollar|eur|euro)',
            # Commands
            r'cmd\.exe', r'powershell\.exe', r'vssadmin', r'wmic', r'bcdedit',
            # Registry
            r'HKEY_', r'CurrentVersion', r'\\Software\\',
            # File paths
            r'C:\\', r'%[a-zA-Z_]+%',
            # Encryption related
            r'aes', r'rsa', r'encrypt', r'decrypt', r'key', r'iv', r'cipher',
            # Executable and library names
            r'\.exe$', r'\.dll$', r'\.sys$'
        ]
        
        # Extract strings matching patterns
        extracted_strings = []
        for string in strings:
            string_clean = string.strip()
            if not string_clean or len(string_clean) < 4:
                continue
                
            # Skip very common strings that would cause false positives
            if string_clean.lower() in ['http://', 'https://', 'www', '.com', '.exe', '.dll']:
                continue
                
            # Check if string matches any interesting pattern
            for pattern in interesting_patterns:
                if re.search(pattern, string_clean, re.IGNORECASE):
                    extracted_strings.append(string_clean)
                    break
        
        # Remove duplicates while preserving order
        seen = set()
        unique_strings = []
        for string in extracted_strings:
            if string not in seen:
                seen.add(string)
                unique_strings.append(string)
        
        # Process strings for YARA compatibility
        for i, string in enumerate(unique_strings):
            # Escape special characters
            escaped_string = string.replace('\\', '\\\\').replace('"', '\\"')
            
            # Determine string type (text or wide)
            string_type = "ascii"
            if re.search(r'[^\x00-\x7F]', string):  # Contains non-ASCII chars
                string_type = "wide"
            elif re.search(r'[A-Za-z]', string) and len(string) > 8:  # Contains letters and is reasonably long
                string_type = "ascii wide"  # Try both ASCII and wide
                
            # Add to yara strings
            string_id = f"s{i}"
            yara_strings.append({
                "id": string_id,
                "type": string_type,
                "value": escaped_string,
                "original": string
            })
        
        return yara_strings[:30]  # Limit to 30 strings to avoid overly complex rules
    
    def _extract_file_operations(self, sample_data: Dict) -> List[str]:
        """
        Extract file operations for YARA rules
        
        Args:
            sample_data: Sample analysis data
            
        Returns:
            List of file paths
        """
        file_paths = set()
        
        # Extract created files
        created_files = sample_data.get('analysis', {}).get('behaviors', {}).get('created_files', [])
        for file_path in created_files:
            # Normalize and escape path
            path = file_path.replace('\\', '\\\\').replace('"', '\\"')
            file_paths.add(path)
        
        # Extract file operations
        file_ops = sample_data.get('analysis', {}).get('behaviors', {}).get('file_operations', [])
        for op in file_ops:
            if 'path' in op:
                path = op['path'].replace('\\', '\\\\').replace('"', '\\"')
                file_paths.add(path)
        
        return list(file_paths)[:20]  # Limit to 20 paths
    
    def _extract_registry_keys(self, sample_data: Dict) -> List[str]:
        """
        Extract registry keys for YARA rules
        
        Args:
            sample_data: Sample analysis data
            
        Returns:
            List of registry keys
        """
        registry_keys = set()
        
        # Extract registry keys
        reg_keys = sample_data.get('analysis', {}).get('behaviors', {}).get('registry', {}).get('keys_set', [])
        for key in reg_keys:
            # Normalize and escape key
            key = key.replace('\\', '\\\\').replace('"', '\\"')
            registry_keys.add(key)
        
        return list(registry_keys)[:10]  # Limit to 10 keys
    
    def generate_yara_rule(self, sample_data: Dict, correlation_result: Dict = None) -> str:
        """
        Generate a YARA rule from sample analysis data and correlation results
        
        Args:
            sample_data: Sample analysis data
            correlation_result: Optional correlation results
            
        Returns:
            Path to the generated YARA rule file
        """
        # If correlation_result is not provided, use sample_data
        if not correlation_result:
            correlation_result = sample_data
        
        # Extract strings for YARA rule
        yara_strings = self._extract_yara_strings(sample_data)
        
        # Extract file paths
        file_paths = self._extract_file_operations(sample_data)
        
        # Extract registry keys
        registry_keys = self._extract_registry_keys(sample_data)
        
        # Combine all extractions
        all_strings = yara_strings.copy()
        
        # Add file paths
        for i, path in enumerate(file_paths):
            string_id = f"file{i}"
            all_strings.append({
                "id": string_id,
                "type": "wide ascii",
                "value": path,
                "original": path
            })
        
        # Add registry keys
        for i, key in enumerate(registry_keys):
            string_id = f"reg{i}"
            all_strings.append({
                "id": string_id,
                "type": "wide ascii",
                "value": key,
                "original": key
            })
        
        # Create string definitions for YARA rule
        string_definitions = ""
        for string in all_strings:
            string_definitions += f"        ${string['id']} = \"{string['value']}\" {string['type']}\n"
        
        # Create condition
        string_count = len(all_strings)
        if string_count <= 5:
            # If few strings, require all of them
            condition = " and ".join([f"${s['id']}" for s in all_strings])
        else:
            # If many strings, require a percentage of them
            min_strings = max(3, int(string_count * 0.3))  # At least 30% of strings or 3, whichever is greater
            condition = f"uint16(0) == 0x5A4D and {min_strings} of them"  # Check for MZ header and strings
        
        # Get family name and confidence
        family_name = "unknown"
        confidence = "low"
        if correlation_result and "identified_families" in correlation_result and correlation_result["identified_families"]:
            top_family = correlation_result["identified_families"][0]
            family_name = top_family["name"]
            confidence_value = top_family.get("confidence", 0.0)
            if confidence_value > 0.8:
                confidence = "high"
            elif confidence_value > 0.5:
                confidence = "medium"
            else:
                confidence = "low"
        
        # Determine threat level
        threat_level = "medium"
        if correlation_result and correlation_result.get("is_ransomware", False):
            threat_level = "high"
        
        # Generate tags
        tags = []
        if correlation_result:
            if "threat_intel" in correlation_result:
                threat_intel = correlation_result["threat_intel"]
                if "alienvault" in threat_intel and "tags" in threat_intel["alienvault"]:
                    tags.extend(threat_intel["alienvault"]["tags"])
                if "mitre" in threat_intel and "tactics" in threat_intel["mitre"]:
                    for tactic in threat_intel["mitre"]["tactics"]:
                        tags.append(tactic.get("name", "").replace(" ", "_").lower())
            
            if "identified_families" in correlation_result:
                for family in correlation_result["identified_families"]:
                    tags.append(f"ransomware_{family['name']}")
        
        # Always add these tags
        tags.append("ransomware")
        tags.append("autogenerated")
        
        # Remove duplicates and format
        tags = list(set([tag.lower() for tag in tags if tag]))
        tags_str = ", ".join(tags)
        
        # Create a unique rule name based on family or hash
        sample_id = sample_data.get("sha256", "")[:8]
        if not sample_id:
            sample_id = str(uuid.uuid4())[:8]
        
        rule_name = f"Ransomware_{family_name.capitalize()}_{sample_id}"
        rule_name = re.sub(r'[^\w]', '_', rule_name)  # Replace non-word chars with underscore
        
        # Create description
        if family_name != "unknown":
            description = f"Detects {family_name} ransomware"
        else:
            description = "Detects potential ransomware behavior"
        
        if "threat_intel" in correlation_result and "mitre" in correlation_result["threat_intel"]:
            mitre = correlation_result["threat_intel"]["mitre"]
            if "description" in mitre:
                description = mitre["description"]
        
        # Get reference
        reference = ""
        if "threat_intel" in correlation_result:
            threat_intel = correlation_result["threat_intel"]
            if "alienvault" in threat_intel and "references" in threat_intel["alienvault"]:
                references = threat_intel["alienvault"]["references"]
                if references:
                    reference = references[0]
        
        # Load template
        template_path = os.path.join(self.templates_dir, 'ransomware_template.yara')
        with open(template_path, 'r') as f:
            template = f.read()
        
        # Fill template
        rule_content = template.format(
            rule_name=rule_name,
            description=description,
            date=datetime.datetime.now().strftime('%Y-%m-%d'),
            hash=sample_data.get("sha256", "unknown"),
            family=family_name,
            confidence=confidence,
            threat_level=threat_level,
            reference=reference,
            tags=tags_str,
            string_definitions=string_definitions,
            condition=condition
        )
        
        # Save rule
        rule_file = os.path.join(self.rules_dir, f"{rule_name}.yar")
        with open(rule_file, 'w') as f:
            f.write(rule_content)
        
        logger.info(f"Generated YARA rule: {rule_file}")
        return rule_file
    
    def generate_family_rule(self, samples: List[Dict]) -> str:
        """
        Generate a YARA rule for a family based on multiple samples
        
        Args:
            samples: List of sample correlation results
            
        Returns:
            Path to the generated YARA rule file
        """
        if not samples or len(samples) < 2:
            logger.warning("At least 2 samples are required to generate a family rule")
            return None
        
        # Find common family
        family_counts = {}
        for sample in samples:
            if "identified_families" in sample and sample["identified_families"]:
                family = sample["identified_families"][0]["name"]
                family_counts[family] = family_counts.get(family, 0) + 1
        
        if not family_counts:
            logger.warning("No family information found in samples")
            return None
        
        # Get most common family
        family_name = max(family_counts.items(), key=lambda x: x[1])[0]
        
        # Extract strings from all samples
        all_string_values = []
        for sample in samples:
            strings = self._extract_yara_strings(sample)
            all_string_values.extend([s["original"] for s in strings])
        
        # Find common strings (appear in at least 2 samples)
        string_counts = {}
        for string in all_string_values:
            string_counts[string] = string_counts.get(string, 0) + 1
        
        common_strings = [s for s, count in string_counts.items() if count >= 2]
        
        # Process common strings for YARA
        yara_strings = []
        for i, string in enumerate(common_strings[:20]):  # Limit to 20 strings
            escaped_string = string.replace('\\', '\\\\').replace('"', '\\"')
            string_type = "ascii"
            if re.search(r'[^\x00-\x7F]', string):
                string_type = "wide"
            elif re.search(r'[A-Za-z]', string) and len(string) > 8:
                string_type = "ascii wide"
                
            string_id = f"s{i}"
            yara_strings.append({
                "id": string_id,
                "type": string_type,
                "value": escaped_string
            })
        
        # Create string definitions
        string_definitions = ""
        for string in yara_strings:
            string_definitions += f"        ${string['id']} = \"{string['value']}\" {string['type']}\n"
        
        # Create condition
        string_count = len(yara_strings)
        if string_count <= 3:
            condition = " and ".join([f"${s['id']}" for s in yara_strings])
        else:
            min_strings = max(3, int(string_count * 0.5))  # At least 50% of strings or 3
            condition = f"uint16(0) == 0x5A4D and {min_strings} of them"
        
        # Determine confidence and threat level
        confidence = "medium"
        if len(samples) >= 5:
            confidence = "high"
        
        # Create description
        description = f"Detects {family_name} ransomware family (based on {len(samples)} samples)"
        
        # Generate tags
        tags = [f"ransomware_{family_name}", "ransomware", "family_rule", "autogenerated"]
        tags_str = ", ".join(tags)
        
        # Create a unique rule name
        rule_name = f"Ransomware_Family_{family_name.capitalize()}"
        rule_name = re.sub(r'[^\w]', '_', rule_name)
        
        # Load template
        template_path = os.path.join(self.templates_dir, 'ransomware_template.yara')
        with open(template_path, 'r') as f:
            template = f.read()
        
        # Fill template
        rule_content = template.format(
            rule_name=rule_name,
            description=description,
            date=datetime.datetime.now().strftime('%Y-%m-%d'),
            hash="multiple",
            family=family_name,
            confidence=confidence,
            threat_level="high",
            reference="",
            tags=tags_str,
            string_definitions=string_definitions,
            condition=condition
        )
        
        # Save rule
        rule_file = os.path.join(self.rules_dir, f"{rule_name}.yar")
        with open(rule_file, 'w') as f:
            f.write(rule_content)
        
        logger.info(f"Generated family YARA rule: {rule_file}")
        return rule_file


if __name__ == "__main__":
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(description="Generate YARA rules from ransomware samples")
    parser.add_argument('--file', '-f', help='Path to analysis JSON file')
    parser.add_argument('--directory', '-d', help='Path to directory with analysis JSON files')
    parser.add_argument('--output', '-o', help='Output directory for YARA rules')
    
    args = parser.parse_args()
    
    if not args.file and not args.directory:
        parser.print_help()
        sys.exit(1)
    
    generator = YaraRuleGenerator(rules_dir=args.output)
    
    if args.file:
        try:
            with open(args.file, 'r') as f:
                sample_data = json.load(f)
            
            rule_path = generator.generate_yara_rule(sample_data)
            print(f"Generated YARA rule: {rule_path}")
        except Exception as e:
            logger.error(f"Error generating rule from file: {e}")
            sys.exit(1)
    
    if args.directory:
        try:
            # Find all JSON files
            json_files = [os.path.join(args.directory, f) for f in os.listdir(args.directory) 
                         if f.endswith('.json') and os.path.isfile(os.path.join(args.directory, f))]
            
            if not json_files:
                logger.error(f"No JSON files found in {args.directory}")
                sys.exit(1)
            
            # Load samples
            samples = []
            for json_file in json_files:
                try:
                    with open(json_file, 'r') as f:
                        sample_data = json.load(f)
                    samples.append(sample_data)
                    # Generate individual rule
                    generator.generate_yara_rule(sample_data)
                except Exception as e:
                    logger.error(f"Error processing {json_file}: {e}")
            
            # Generate family rule if we have enough samples
            if len(samples) >= 2:
                family_rule = generator.generate_family_rule(samples)
                if family_rule:
                    print(f"Generated family YARA rule: {family_rule}")
            
            print(f"Generated {len(samples)} individual YARA rules")
        except Exception as e:
            logger.error(f"Error processing directory: {e}")
            sys.exit(1)